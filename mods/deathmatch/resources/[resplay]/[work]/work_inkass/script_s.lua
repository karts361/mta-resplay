local resplayResource = getResourceFromName("resplay") -- Ресурс resplaylocal resplayRoot = getResourceRootElement(resplayResource) -- Root-элемент ресурса resplaylocal jobInkassIncMoney = 12000local jonInkassMoneyForLeftCar = 100local jobInkassTimeBackToVeh = 60000local jobInkassCpCoords = {}local jobInkassMoneyCpCords = {}local jobInkassCarCoords = {}local jobInkassCars = {}local jobInkassCps = {}local jobInkassCpBlips = {}local inkassPedMdl = 71local inkassCar = 428local inkassPed = nillocal inkassCarBlip = nillocal inkassTargetMarker = nillocal jobInkassVehMarker = nillocal inkassVehs = { -- фургоны}local inkassFinishMarkers = { -- Маркеры завершения работы	{ 2464.3999, -2589.7, 13.7 },	{ -1974.6, 171.7, 27.7 },	{ 1107.2, 2360, 10.8 }}local inkassFixMarkers = { -- Маркеры починки и заправки	{ 2505.7, -2634.2, 13.6 },	{ -1973.3, 202.39999, 27.2 },	{ 1091, 2355.8, 10.8 }}local inkassMarkers = { cords} -- Координатыlocal busVehiclesPerPath = {} -- Количество ТС на маршрутах-- Инициализация новой работы(событие onResourceStart)function inkassInit()	local newVeh, newMarker, nextPoint, newBlip, newColorR, newColorG, newColorB, prevStation, curStation	busWorkId = exports.resplay:workNew("Инкассатор") -- Создаём новую работу и узнаём её ID	exports.resplay:groupAttachVehicleToGroup(busVehicleId, busGroupId) -- Присоединяем рабочий транспорт к группе игроков	exports.resplay:workAttachVehicleToWork(busVehicleId, busWorkId) -- Присоединяем рабочий транспорт к работе	-- Создаём фургоны	for _,vehCoord in ipairs(busVehCoords) do		newVeh = createVehicle(busVehicleId, 0, 0, 0)		spawnVehicle(newVeh, vehCoord[1], vehCoord[2], vehCoord[3], vehCoord[4], vehCoord[5], vehCoord[6])		setVehicleRespawnPosition(newVeh, vehCoord[1], vehCoord[2], vehCoord[3], vehCoord[4], vehCoord[5], vehCoord[6])		setElementFrozen(newVeh, true)		setVehicleDamageProof(newVeh, true)		setVehicleEngineState(newVeh, false)	end	-- Маркеры завершения и починки/заправки	for i,finMarker in ipairs(busFinishMarkers) do		newMarker = createMarker(finMarker[1], finMarker[2], finMarker[3], "checkpoint", 4, 255, 0, 0, 128)		newBlip = createBlip(0, 0, 0, 53, 2, 255, 255, 255, 255, 32766)		attachElements(newBlip, newMarker)		setMarkerIcon(newMarker, "finish")		setElementVisibleTo(newMarker, root, false)		setElementVisibleTo(newBlip, root, false)		addEventHandler("onMarkerHit", newMarker, busFinishHit)		exports.resplay:pickupSetText(newMarker, "Завершить работу", 255, 0, 0)		busFinishMarkers[i] = newMarker	end	for i,fixMarker in ipairs(busFixMarkers) do		newMarker = createMarker(fixMarker[1], fixMarker[2], fixMarker[3], "checkpoint", 4, 255, 255, 0, 128)		newBlip = createBlip(0, 0, 0, 63, 2, 255, 255, 255, 255, 32766)		attachElements(newBlip, newMarker)		setElementVisibleTo(newMarker, root, false)		setElementVisibleTo(newBlip, root, false)		addEventHandler("onMarkerHit", newMarker, busFixHit)		exports.resplay:pickupSetText(newMarker, "Ремонт и заправка", 255, 255, 0)		busFixMarkers[i] = newMarker	end	-- Инициализируем маршруты	local curCol = createColSphere(0, 0, 0, 25)	local colObjs, stopObj, minDist, curDist, ox, oy, oz	local busClientInfoBase = {}	for i,path in ipairs(busPaths) do		table.insert(busClientInfoBase, {})		newPathLen = 0		prevStation = nil		curStation = nil		for j,point in ipairs(path) do			if point[5] then				newColorR = 255				newColorG = 0				newColorB = 0				setElementPosition(curCol, point[1], point[2], point[3])				colObjs = getElementsWithinColShape(curCol, "object")				stopObj = nil				minDist = nil				for _,curObj in ipairs(colObjs) do					if(getElementModel(curObj) == 1257) then						ox, oy, oz = getElementPosition(curObj)						curDist = getDistanceBetweenPoints3D(point[1], point[2], point[3], ox, oy, oz)						if(not minDist) or (minDist > curDist) then							minDist = curDist							stopObj = curObj						end					end				end				table.insert(busClientInfoBase[i], { stopObj, nil, prevStation, curStation, point[6] })				prevStation = curStation				curStation = point[6]			else				newColorR = 255				newColorG = 255				newColorB = 0			end			newMarker = createMarker(point[1], point[2], point[3], "checkpoint", 4.0, newColorR, newColorG, newColorB, 128)			newBlip = createBlip(0, 0, 0, 0, 2, newColorR, newColorG, newColorB, 255, 32767)			attachElements(newBlip, newMarker)			_, nextPoint = busGetNextPoint(i, j)			setMarkerIcon(newMarker, "arrow")			setMarkerTarget(newMarker, nextPoint[1], nextPoint[2], nextPoint[3])			setElementVisibleTo(newMarker, root, false)			setElementVisibleTo(newBlip, root, false)			addEventHandler("onMarkerHit", newMarker, busMarkerHit)			addEventHandler("onMarkerLeave", newMarker, busMarkerHit)			busPaths[i][j][4] = newMarker		end		busClientInfoBase[i][1][3] = prevStation		busClientInfoBase[i][1][4] = curStation		busClientInfoBase[i][2][3] = curStation		table.insert(busVehiclesPerPath, 0)	end	for _,busPathInfo in ipairs(busClientInfoBase) do		for _,busPointInfo in ipairs(busPathInfo) do			table.insert(busClientInfo, busPointInfo)		end	end	triggerClientEvent("onBusStopsUpdate", resourceRoot, busClientInfo)end-- Вызывается, когда игрок начинает работу(событие onWorkStart)function busStart(workId, workPlayer, workVehicle)	if busWorkId and(workId == busWorkId) and isElement(workVehicle) and isElement(workPlayer) then -- Скрипт должен выполняться, когда событие вызывается для текущей работы		-- Подбор маршрута		local firstPointId = 1		local routeId, routeVehCount, firstPoint		for i,vehCount in ipairs(busVehiclesPerPath) do			if(not routeVehCount) or (vehCount < routeVehCount) then				routeId = i				routeVehCount = vehCount			end		end		-- Инициализация параметров текущей работы		busParamIdRoute = exports.resplay:workAddWorkerParam(busWorkId, workPlayer, routeId)		busParamIdPoint = exports.resplay:workAddWorkerParam(busWorkId, workPlayer, firstPointId)		busParamIdTimer = exports.resplay:workAddWorkerParam(busWorkId, workPlayer, false)		busParamIdMarker = exports.resplay:workAddWorkerParam(busWorkId, workPlayer, false)		_, firstPoint = busGetCurrentPoint(routeId, firstPointId)		setElementVisibleTo(firstPoint[4], workPlayer, true)		local pointBlip = getAttachedBlip(firstPoint[4])		setElementVisibleTo(pointBlip, workPlayer, true)		for _,fixMark in ipairs(busFixMarkers) do			setElementVisibleTo(fixMark, workPlayer, true)			pointBlip = getAttachedBlip(fixMark)			setElementVisibleTo(pointBlip, workPlayer, true)		end		for _,finMark in ipairs(busFinishMarkers) do			setElementVisibleTo(finMark, workPlayer, true)			pointBlip = getAttachedBlip(finMark)			setElementVisibleTo(pointBlip, workPlayer, true)		end		addEventHandler("onVehicleExplode", workVehicle, busBlowedUp)		addEventHandler("onPlayerWasted", workPlayer, busWasted)		addEventHandler("onVehicleExit", workVehicle, busVehicleLeave)		addEventHandler("onVehicleEnter", workVehicle, busVehicleNewPassenger)		busVehiclesPerPath[routeId] = busVehiclesPerPath[routeId] + 1		exports.resplay:playerShowMessage(workPlayer, "Двигайтесь к первой остановке своего маршрута и начинайте движение по нему.")	endend-- Функции, специфичные для данной работыfunction busGetCurrentPoint(pathId, pointId)	return pointId, busPaths[pathId][pointId]endfunction busGetNextPoint(pathId, pointId)	local nextPointId	if(pointId < table.getn(busPaths[pathId])) then		nextPointId = pointId+1	else		nextPointId = 1	end	return nextPointId, busPaths[pathId][nextPointId]endfunction busGetPrevPoint(pathId, pointId)	local prevPointId	if(pointId > 1) then		prevPointId = pointId-1	else		prevPointId = table.getn(busPaths[pathId])	end	return prevPointId, busPaths[pathId][prevPointId]endfunction busMarkerHit(workPlayer, matchingDimension)	if isElementVisibleTo(source, workPlayer) and matchingDimension then		local pointInfo		local pathId = exports.resplay:workGetWorkerParam(busWorkId, workPlayer, busParamIdRoute)		local pointId = exports.resplay:workGetWorkerParam(busWorkId, workPlayer, busParamIdPoint)		_, pointInfo = busGetCurrentPoint(pathId, pointId)		setElementVisibleTo(pointInfo[4], workPlayer, false)		local pointBlip = getAttachedBlip(pointInfo[4])		setElementVisibleTo(pointBlip, workPlayer, false)		triggerClientEvent(workPlayer, "onWorkEnterCp", resourceRoot)		pointId, pointInfo = busGetNextPoint(pathId, pointId)		if(pointId == 1) then			exports.resplay:playerGiveMoney(workPlayer, busPricePerPath)			exports.resplay:playerRespectChange(workPlayer, 0.00015, -1.0, 0.25, true)			exports.resplay:playerShowMessage(workPlayer, "Вы прошли полный круг по маршруту и получили деньги и репутацию за него.")		end		setElementVisibleTo(pointInfo[4], workPlayer, true)		pointBlip = getAttachedBlip(pointInfo[4])		setElementVisibleTo(pointBlip, workPlayer, true)		if pointInfo[5] then			exports.resplay:playerShowMessage(workPlayer, "Подберите пассажиров около остановки и продолжайте движение по маршруту.")		end		exports.resplay:workSetWorkerParam(busWorkId, workPlayer, busParamIdPoint, pointId)	endendfunction busFinishHit(workPlayer, matchingDimension)	if isElementVisibleTo(source, workPlayer) and matchingDimension then		local veh = getPedOccupiedVehicle(workPlayer)		if veh then			local workVeh = exports.resplay:workGetWorkVehicle(busWorkId, workPlayer)			if workVeh and(veh == workVeh) then				busFinish(workPlayer)			end		end	endendfunction busFixHit(workPlayer, matchingDimension)	if isElementVisibleTo(source, workPlayer) and matchingDimension then		local veh = getPedOccupiedVehicle(workPlayer)		if veh then			local workVeh = exports.resplay:workGetWorkVehicle(busWorkId, workPlayer)			if workVeh and(veh == workVeh) then				fixVehicle(veh)				setElementData(veh, "fuelLevel", 1.0)				exports.resplay:soundPlaySFX3D("script", 150, 0, 0, 0, 0, false, 100, veh)			end		end	endendfunction getAttachedBlip(curMarker)	local attachedElements = getAttachedElements(curMarker)	local attachedBlip	for _,elem in ipairs(attachedElements) do		if(getElementType(elem) == "blip") then			attachedBlip = elem			break		end	end	return attachedBlipendfunction busStopsUpdate()	triggerClientEvent(source, "onBusStopsUpdate", resourceRoot, busClientInfo)end-- Завершение работыfunction busWasted() -- Работник погиб	exports.resplay:playerOutputLog(source, "Автобус - Завершение - Погиб", true)	exports.resplay:workFinish(busWorkId, source, 2)endfunction busBlowedUp() -- Взрыв рабочего транспорта	local workPlayer = exports.resplay:workGetWorkerByVehicle(busWorkId, source)	if workPlayer then		local money = exports.resplay:playerGetMoney(workPlayer)		exports.resplay:playerOutputLog(source, "Автобус - Завершение - Взрыв транспорта", true)		exports.resplay:playerTakeMoney(workPlayer, math.min(busMoneyForBlowedCar, money))		exports.resplay:workFinish(busWorkId, workPlayer, 4)	endendfunction busVehicleLeave(thePlayer, seat) -- Работник вышел из рабочего транспорта	if(seat == 0) then		local workPlayer = exports.resplay:workGetWorkerByVehicle(busWorkId, source)		if(workPlayer == thePlayer) and(exports.resplay:workGetState(busWorkId, workPlayer) == 0) then			local busTimer = exports.resplay:workGetWorkerParam(busWorkId, workPlayer, busParamIdTimer)			if isTimer(busTimer) then				killTimer(busTimer)			end			local busVehMarker = exports.resplay:workGetWorkerParam(busWorkId, workPlayer, busParamIdMarker)			if isElement(busVehMarker) then				destroyElement(busVehMarker)			end			busVehMarker = createMarker(0, 0, 0, "arrow", 2.0, 255, 255, 0, 255, workPlayer)			attachElements(busVehMarker, source, 0, 0, 5)			busTimer = setTimer(busVehicleLeft, 60000, 1, workPlayer)			exports.resplay:workSetWorkerParam(busWorkId, workPlayer, busParamIdTimer, busTimer)			exports.resplay:workSetWorkerParam(busWorkId, workPlayer, busParamIdMarker, busVehMarker)			exports.resplay:playerShowMessage(workPlayer, "У вас есть 60 секунд, чтобы вернуться в автобус.")			exports.resplay:workSetState(busWorkId, workPlayer, 1)			addEventHandler("onVehicleEnter", source, busVehicleReturn)		end	endendfunction busVehicleNewPassenger(thePlayer, seat)	if(seat ~= 0) then		local workPlayer = exports.resplay:workGetWorkerByVehicle(busWorkId, source)		if(workPlayer ~= thePlayer) then			if exports.resplay:playerTransferMoney(thePlayer, workPlayer, busPricePerPassenger) then				exports.resplay:playerShowMessage(thePlayer, "Вы оплатили $"..busPricePerPassenger.." за поездку на автобусе.")			else				removePedFromVehicle(thePlayer)				exports.resplay:playerShowMessage(thePlayer, "У вас недостаточно денег. Поездка на автобусе стоит $"..busPricePerPassenger..".")			end		end	endendfunction busVehicleReturn(thePlayer, seat) -- Работник вернулся в транспорт	if(seat == 0) then		local workPlayer = exports.resplay:workGetWorkerByVehicle(busWorkId, source)		if(workPlayer == thePlayer) and(exports.resplay:workGetState(busWorkId, workPlayer) == 1) then			removeEventHandler("onVehicleEnter", source, busVehicleReturn)			local busTimer = exports.resplay:workGetWorkerParam(busWorkId, workPlayer, busParamIdTimer)			if isTimer(busTimer) then				killTimer(busTimer)			end			local busMarker = exports.resplay:workGetWorkerParam(busWorkId, workPlayer, busParamIdMarker)			if isElement(busMarker) then				destroyElement(busMarker)			end			exports.resplay:workSetWorkerParam(busWorkId, workPlayer, busParamIdMarker, false)			exports.resplay:workSetWorkerParam(busWorkId, workPlayer, busParamIdTimer, false)			exports.resplay:workSetState(busWorkId, workPlayer, 0)		end	endendfunction busVehicleLeft(workPlayer) -- Работник не вернулся в транспорт	local money = exports.resplay:playerGetMoney(workPlayer)	exports.resplay:playerOutputLog(workPlayer, "Автобус - Завершение - Покинул транспорт", true)	exports.resplay:playerTakeMoney(workPlayer, math.min(busMoneyForLeftCar, money))	exports.resplay:workFinish(busWorkId, workPlayer, 3)endfunction busFinish(workPlayer) -- Работник завершил работу успешно	exports.resplay:playerOutputLog(workPlayer, "Автобус - Завершение - Успех", true)	exports.resplay:workFinish(busWorkId, workPlayer, 1)endfunction busFinishPost(workId, workPlayer, reason)	if busWorkId and(workId == busWorkId) then		local workVehicle = exports.resplay:workGetWorkVehicle(busWorkId, workPlayer)		if isElement(workVehicle) then			removeEventHandler("onVehicleExplode", workVehicle, busBlowedUp)			removeEventHandler("onPlayerWasted", workPlayer, busWasted)			removeEventHandler("onVehicleExit", workVehicle, busVehicleLeave)			removeEventHandler("onVehicleEnter", workVehicle, busVehicleNewPassenger)			local busTimer = exports.resplay:workGetWorkerParam(busWorkId, workPlayer, busParamIdTimer)			if isTimer(busTimer) then				killTimer(busTimer)			end			local busVehMarker = exports.resplay:workGetWorkerParam(busWorkId, workPlayer, busParamIdMarker)			if isElement(busVehMarker) then				destroyElement(busVehMarker)			end			local routeId = exports.resplay:workGetWorkerParam(busWorkId, workPlayer, busParamIdRoute)			busVehiclesPerPath[routeId] = busVehiclesPerPath[routeId] - 1			local pointId = exports.resplay:workGetWorkerParam(busWorkId, workPlayer, busParamIdPoint)			_, pointInfo = busGetCurrentPoint(routeId, pointId)			setElementVisibleTo(pointInfo[4], workPlayer, false)			local pointBlip = getAttachedBlip(pointInfo[4])			setElementVisibleTo(pointBlip, workPlayer, false)			for _,fixMark in ipairs(busFixMarkers) do				setElementVisibleTo(fixMark, workPlayer, false)				pointBlip = getAttachedBlip(fixMark)				setElementVisibleTo(pointBlip, workPlayer, false)			end			for _,finMark in ipairs(busFinishMarkers) do				setElementVisibleTo(finMark, workPlayer, false)				pointBlip = getAttachedBlip(finMark)				setElementVisibleTo(pointBlip, workPlayer, false)			end		end	endend-- Выгрузка скриптаfunction busDestroy()	local thisResource = getThisResource()	if(getResourceState(thisResource) == "running") then		stopResource(thisResource)	endendaddEventHandler("onWorkSendClientInfo", root, busStopsUpdate)addEventHandler("onWorkInit", resplayRoot, busInit)addEventHandler("onWorkDestroy", resplayRoot, busDestroy)addEventHandler("onWorkStart", resplayRoot, busStart)addEventHandler("onWorkFinish", resplayRoot, busFinishPost)